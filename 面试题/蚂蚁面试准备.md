# 以往面经查看

## TreeSet & HashSet的区别

1、实现方式，HashSet 哈希表，TreeSet 红黑树

2、都不允许存相同的对象，这个相同由自己定义，HashSet通过重写对象的equail和hashcode方法，TreeSet通过类实现Comparable接口，获取将比较对象作为TreeSet的构造函数参数传入

3、HashSet数据无序，TreeSet有序，可使用LinkedHashSet 实现有序

4、存取数据时间复杂度不同，HashSet  O（1） TreeSet 自平衡的二叉树 O（logn）

## 多个线程等到某个节点，统一放行的方式

？？ 没太懂

考 join方法？

还是countLatch（减少）  cylicBarrier（增加）

## CAP了解吗？Redis中的CAP

Consistency (一致性)

Availability (可用性)

Partition Tolerance (分区容错性)

只能保证其中的两个，P必须保证，所以必须选择A or C



Redis的**单机版本**中，由于只有一个Master节点，所有客户端都是访问一个Master节点，不会出现数据不一致问题，保证了C**强一致性**，如果出现单点故障，那么Master节点直接挂掉，所有客户端都不可访问，那么就会不可用，牺牲了**A可用性**



Redis 集群Cluster，变成了分布式NoSQL数据库，CAP模型也从CP变成了AP。多个Master节点通过数据分片和数据冗余，Redis具有了真正的分布式能力，某个结点挂了的话，因为数据在其他结点上有备份，所以其他结点顶上来就可以继续提供服务，保证了**Availability**。但是如果某一个Master挂了，数据还没有同步，那么就会出现**数据不一致**。



## 如何理解幂等，项目中幂等如何做？

任意多次执行所产生的影响均与一次执行的影响相同，java中，通常指接口调用多次和调用一次所造成的影响是一样的。

在分布式系统中，可能由于网络问题造成重试操作，需要服务保证幂等。

### 实现幂等

前端：

对于有交互的方式，可以在前端过滤一部分，如防止表单重复提交，按钮置灰，隐藏，不可点击等方式。但是这对普通用户有效，不能阻止直接调用接口，实现多次调用。

后端：

**数据库唯一性校验**：使用数据库主键的唯一约束，在操作时传过来一个唯一id，插入时如果已经执行过那么肯定会报错，这个时候直接报错回滚就行，比较简单粗暴。

**状态机**：通常业务系统都会存在不同的状态，状态之间是有联系 或者先后关系的，可以通过状态字段来保证操作不会造成影响。比如单据审批状态，**更新状态时加上状态判断。**

**Token机制**：调用方在调用接口的时候先向后端请求一个全局ID（TOKEN），请求的时候携带这个全局ID一起请求，后端需要对这个全局ID校验来保证幂等操作。

![image-20210508002232776](assets/image-20210508002232776.png)



## 反射能获取啥？能否获取参数名称、参数类型？

应该可以吧，待测试





## 两个有序的list，求交集

retainall？

stream流遍历，判断list1 是否包含当前元素，如果包含则collect.tolist