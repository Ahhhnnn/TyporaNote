# Mysql Count(*) 慢怎么办？

## count(*) 的实现方式

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；
- 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

Innodb由于MVCC存在的原因，导致“应该返回多少行”也是不确定的。**（在一个事务内，还没提及的情况下，无法看见其他事务插入的数据，导致返回结果不准确）**



### 遍历索引

InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。普通索引树比主键索引树小很多。

对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。**



### show table status

这个命令可以返回表的数据行，但是是基于采样来估算，结果并不准确，官网说明可能误差达到40 - 50%





## 不同count的区别

count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；而 count(字段），则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数

**对于 count(主键 id) 来说**

，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。**对于 count(1) 来说**，

InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。

**对于 count(字段) 来说**：

如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；

如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

**但是 count(*) 是例外**

并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加

效率比较：





### 小结

- MyISAM 表虽然 count(*) 很快，但是不支持事务；*
- *show table status 命令虽然返回很快，但是不准确；*
- *InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。



## 如果有需要经常显示操作总数的需求如何做？

### Redis保存记数





### 数据库保存记数





