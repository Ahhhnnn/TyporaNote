# 缓存污染了怎么办？

在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。

如果缓存空间大小足够，那么不会有影响，如果空间不够，那么使用淘汰策略会引起额外的开销。

## 淘汰策略

noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu。



## 选择淘汰策略

volatile-ttl ：只有在业务明确知道访问频率、时间情况下能避免缓存污染。

random无法有效避免缓存污染。

## LRU淘汰策略

如果一个数据刚刚被访问，那么这个数据肯定是热数据，还会被再次访问。

Redis 中的 LRU 策略，会在每个数据对应的 RedisObject 结构体中设置一个 lru 字段，用来记录数据的访问时间戳。在进行数据淘汰时，LRU 策略会在候选数据集中淘汰掉 lru 字段值最小的数据。

解决不了缓存污染问题：

**因为只看数据的访问时间，使用 LRU 策略在处理扫描式单次查询操作时，无法解决缓存污染。所谓的扫描式单次查询操作，就是指应用对大量的数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次。此时，因为这些被查询的数据刚刚被访问过，所以 lru 字段值都很大**



redis中的LRU并不是传统的LRU采用全局链表实现，而是进行了改进。

Redis 是用 RedisObject 结构来保存数据的，RedisObject 结构中设置了一个 lru 字段，用来记录数据的访问时间戳；Redis 并没有为所有的数据维护一个全局的链表，**而是通过随机采样方式，选取一定数量（例如 10 个）的数据放入候选集合，后续在候选集合中根据 lru 字段值的大小进行筛选。**

## LFU算法

在LRU上进行改进

LFU 策略中会从两个维度来筛选并淘汰数据：

**一是，数据访问的时效性（访问时间离当前时间的远近）；二是，数据的被访问次数。**

LRU为每个数据 RedisObject 增加了一个计数器，也是在lru字段上，高16为存时间，低8为存计数器。由于只有8位，只能存储2的8次方，255。所以需要一个**递增算法**。



计数器的更新策略：

redis提供了两个参数

lfu_log_factor：计数器递增参数

lfu_decay_time：redis衰减策略，如果随时时间推移，没有访问，那么计数器会进行衰减，保证能及时淘汰该数据。



## 总结

解决缓存污染的关键是别出这些只访问一次或是访问次数很少的数据，在淘汰数据时，优先把它们筛选出来并淘汰掉。

实际运用中 LRU & LFU都有应用，根据业务需求来选择。

**LRU 策略更加关注数据的时效性，而 LFU 策略更加关注数据的访问频次。通常情况下，实际应用的负载具有较好的时间局部性，所以 LRU 策略的应用会更加广泛。但是，在扫描式查询的应用场景中，LFU 策略就可以很好地应对缓存污染问题了，建议你优先使用。**



